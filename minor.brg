%{
/*
 * selecção de instruções com postfix
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "tabid.h"
#include "minor.h"

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

int lbl;
int tmpStrInd = 0;
char tmpStr[1024];
char *toPrint = NULL;

extern FILE *yyout;
static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
	return strcpy(malloc(strlen(buf)+1),buf);
}

static void outstr(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
  fprintf(yyout, pfCHAR, 0);
}

static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}
%}
%term STMT=';' PSTMT='!' READOP='?' AND='&' OR='|'
%term POW='^' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' NOT='~' LT='<' GT='>'
%include "y.tab.h"

%%
file : PROGRAM(decls, main) 1 {}

decls : NIL {}
decls : DECL(NIL, decls) {}
decls : VAR(NUMBER(ID, INT)) {
                              fprintf(yyout, pfDATA pfLABEL pfINTEGER,
                              p->SUB(0)->SUB(0)->value.s,
                              p->SUB(0)->SUB(1)->value.i);
                             }
decls : VAR(STRING(ID, chars)) {
                                tmpStr[tmpStrInd++] = '\0'; toPrint = tmpStr;
                                fprintf(yyout, pfRODATA pfALIGN pfLABEL
                                , p->SUB(0)->SUB(0)->value.s);
                                outstr(toPrint);
                                tmpStrInd = 0;
                               }
decls : DECL(decls, decls) {}

main : FUNCTION(END, instrs) {}

instrs : FARGS(NIL, instr) {}

instr : START(NIL, instr) {}

instr : NIL
instr : STMT(NIL, instr)
instr : STMT(instr, instr)
instr : print
instr : expr

print : PSTMT(expr) {fprintf(yyout, pfCALL pfTRASH, "_printi", 4);}
print : PSTMT(READOP) {}
print : PSTMT(ID) {
                  switch(p->SUB(0)->info){
                    case tINT:
                      fprintf(yyout, pfADDRV pfCALL pfTRASH,
                      p->SUB(0)->value.s, "_printi", 4);
                    break;
                    case tSTR:
                      fprintf(yyout, pfADDR pfCALL pfTRASH,
                      p->SUB(0)->value.s, "_prints", 4);
                    break;
                  }
                  }
print : PSTMT(chars) {
                      char *l = mklbl(++lbl); tmpStr[tmpStrInd++] = '\0';
                      fprintf(yyout, pfRODATA pfALIGN pfLABEL, l);
                      outstr(toPrint);
                      fprintf(yyout, pfTEXT pfADDR pfCALL pfTRASH,
                      l, "_prints", 4);
                      tmpStrInd = 0;
                      }
chars : CHARS(NIL, chars) {}
chars : INT { tmpStr[tmpStrInd++] = p->value.i; toPrint = tmpStr;}
chars : CHAR { tmpStr[tmpStrInd++] = p->value.i; toPrint = tmpStr;}
chars : STR { strcpy(&tmpStr[tmpStrInd], p->value.s); tmpStrInd = tmpStrInd + strlen(p->value.s); toPrint = tmpStr;}
chars : CHARS(chars, chars) {}

expr:	CHARS(NIL, INT)	1 {fprintf(yyout, pfIMM, p->SUB(1)->value.i); }

expr:	ADD(expr,expr)	1 { fprintf(yyout, pfADD); }
expr:	SUB(expr,expr)	1 { fprintf(yyout, pfSUB); }
expr:	MUL(expr,expr)	1 { fprintf(yyout, pfMUL); }
expr:	DIV(expr,expr)	1 { fprintf(yyout, pfDIV); }
expr:	MOD(expr,expr)	1 { fprintf(yyout, pfMOD); }
expr:	EQ(expr,expr)	1 { fprintf(yyout, pfEQ); }
expr:	NE(expr,expr)	1 { fprintf(yyout, pfNE); }
expr:	LT(expr,expr)	1 { fprintf(yyout, pfLT); }
expr:	LE(expr,expr)	1 { fprintf(yyout, pfLE); }
expr:	GT(expr,expr)	1 { fprintf(yyout, pfGT); }
expr:	GE(expr,expr)	1 { fprintf(yyout, pfGE); }
expr:	UMINUS(expr)	1 { fprintf(yyout, pfNEG); }
expr:	NOT(expr)	1 { fprintf(yyout, pfIMM pfEQ, 0); }

%%
extern char **yynames;
extern int trace, errors, debugNode;

static int data(int t, char *s, void *a, void *user) {
  if (s) fprintf(yyout, pfLABEL pfINTEGER, s, 0);
  return 1;
}

void evaluate(Node *p) {
	if (errors) return;
	/* if (trace) */ printNode(p, stdout, yynames);
  fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_main", pfFUNC, "_main");
	if (!yyselect(p) && trace) printf("selection successful\n");
  fprintf(yyout, pfIMM pfPOP pfRET pfDATA, 0);
  /*IDevery(data,0);*/
  fprintf(yyout, pfEXTRN pfEXTRN pfEXTRN pfEXTRN,
  		"_prints", "_printi", "_println", "_readi");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (debugNode) fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
		printNode(p, stderr, yynames);
	}
}
#endif
